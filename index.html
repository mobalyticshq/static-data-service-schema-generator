<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Подсчёт верхнеуровневых полей JSON</title>
  <style>
    :root { --radius: 14px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background: #0f1220; color: #f6f7fb; margin: 0; padding: 32px; }
    .card { max-width: 740px; margin: 0 auto; background: #171a2b; border: 1px solid #2a2e4a; border-radius: var(--radius); box-shadow: 0 10px 30px rgba(0,0,0,.35); overflow: hidden; }
    header { padding: 20px 24px; border-bottom: 1px solid #2a2e4a; background: linear-gradient(180deg, rgba(255,255,255,.04), transparent); }
    header h1 { font-size: 20px; margin: 0 0 6px; }
    header p { margin: 0; opacity: .8; font-size: 14px; }
    .content { padding: 22px 24px 26px; display: grid; gap: 18px; }
    label { font-size: 14px; opacity: .9; }
    input[type="file"] { width: 100%; padding: 12px; background: #0f1220; color: #dfe3f5; border: 1px dashed #3a3f66; border-radius: 10px; }
    .actions { display: flex; gap: 12px; align-items: center; }
    button { padding: 10px 14px; border: 0; border-radius: 12px; background: #5561ff; color: white; font-weight: 600; cursor: pointer; transition: transform .02s ease-in, opacity .2s; }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    button:active { transform: translateY(1px); }
    .muted { font-size: 13px; opacity: .75; }
    .error { background: #2a1220; border: 1px solid #7a2a3a; color: #ffb6c1; padding: 10px 12px; border-radius: 10px; display: none; white-space: pre-wrap; }
    .success { background: #13231a; border: 1px solid #2d6b45; color: #c0f3d2; padding: 10px 12px; border-radius: 10px; display: none; }
    pre { margin: 0; padding: 14px; background: #0b0e1a; border: 1px solid #2a2e4a; border-radius: 10px; overflow: auto; }
    a.download { display: inline-flex; align-items: center; gap: 8px; text-decoration: none; background: #1e243f; border: 1px solid #3a3f66; color: #e2e7ff; padding: 8px 12px; border-radius: 10px; }
    footer { padding: 14px 24px 22px; border-top: 1px solid #2a2e4a; display: flex; align-items: center; justify-content: space-between; }
    code { background: #0b0e1a; padding: 2px 6px; border-radius: 6px; border: 1px solid #2a2e4a; }
  </style>
</head>
<body>
<div class="card" role="region" aria-label="JSON tools">
  <header>
    <h1>Подсчёт верхнеуровневых полей JSON</h1>
    <p>Загрузите <strong>.json</strong>-файл, нажмите <em>Process</em> — получите файл <code>result.json</code> вида <code>{"value": n}</code>,
      где <code>n</code> — количество верхнеуровневых полей объекта.</p>
  </header>

  <div class="content">
    <div>
      <label for="fileInput">Файл JSON</label>
      <input id="fileInput" type="file" accept="application/json,.json" />
      <div class="muted" aria-live="polite">Поддерживается только JSON-объект на верхнем уровне (не массив).</div>
    </div>

    <div class="actions">
      <button id="processBtn" disabled>Process</button>
      <button id="resetBtn" class="secondary" type="button" style="background:#2a2e4a">Сброс</button>
      <a id="downloadLink" class="download" href="#" download="result.json" style="display:none">⬇️ Скачать результат</a>
    </div>

    <div id="errorBox" class="error" role="alert"></div>
    <div id="successBox" class="success"></div>

    <div>
      <label>Превью результата</label>
      <pre id="resultPreview">—</pre>
    </div>
  </div>

  <footer>
    <span class="muted">Локальная обработка: файл не покидает ваш браузер.</span>
    <span class="muted">©</span>
  </footer>
</div>

<script>
  //import pluralize from 'pluralize';
  // Constants
  export const FIELD_TYPES = {
    STRING: 'String',
    BOOLEAN: 'Boolean',
    OBJECT: 'Object',
    REF: 'Ref',
  };
  export const FIELD_NAMES = {
    ID: 'id',
    SLUG: 'slug',
  };
  const MANUAL_FILL_PLACEHOLDER = '@@@ TO BE FILLED MANUALLY @@@';
  const REFERENCE_SUFFIX = 'Ref';
  const REF_FIELD_NAME_SUFFIX = 'Ref';
  // Helper functions
  export const capitalize = (s) => {
    if (!s)
      return s;
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  const buildObjectName = (parentPath, objFieldName) => {
    if (!parentPath) {
      return objFieldName;
    }
    return parentPath + capitalize(objFieldName);
  };
  const detectArrayType = (arr) => {
    if (arr.length === 0) {
      return { type: FIELD_TYPES.STRING, valid: false };
    }
    const firstItem = arr[0];
    if (firstItem === null || firstItem === undefined) {
      return { type: FIELD_TYPES.STRING, valid: false };
    }
    switch (typeof firstItem) {
      case 'boolean':
        return { type: FIELD_TYPES.BOOLEAN, valid: true };
      case 'string':
        return { type: FIELD_TYPES.STRING, valid: true };
      case 'object':
        if (firstItem !== null && !Array.isArray(firstItem)) {
          return { type: FIELD_TYPES.OBJECT, valid: true };
        }
        return { type: FIELD_TYPES.STRING, valid: false };
      default:
        return { type: FIELD_TYPES.STRING, valid: false };
    }
  };
  const mergeObjectConfigs = (existing, newConfig) => {
    const result = {
      fields: { ...existing.fields },
    };
    for (const [fieldName, fieldConfig] of Object.entries(newConfig.fields)) {
      if (!(fieldName in result.fields)) {
        result.fields[fieldName] = fieldConfig;
      }
    }
    return result;
  };
  const createGroupConfBuilder = (source, groupName) => ({
    source,
    groupName,
    fields: {},
    objects: {},
  });
  const resolveRefTarget = (builder, fieldName, array) => {
    let refGroup = fieldName.replace(new RegExp(REF_FIELD_NAME_SUFFIX + '$'), '');
    if (!array) {
      // if (pluralize.isSingular(refGroup)) {
      //     refGroup = pluralize.plural(refGroup);
      // }
    }
    if (!(refGroup in builder.source)) {
      return MANUAL_FILL_PLACEHOLDER;
    }
    return refGroup;
  };
  const detectFieldConfig = (builder, fieldName, value) => {
    const fieldConfig = { type: FIELD_TYPES.STRING };
    if (fieldName === FIELD_NAMES.ID) {
      fieldConfig.filter = true;
    }
    switch (typeof value) {
      case 'boolean':
        fieldConfig.type = FIELD_TYPES.BOOLEAN;
        break;
      case 'string':
        fieldConfig.type = FIELD_TYPES.STRING;
        break;
      case 'object':
        if (value === null) {
          return { config: fieldConfig, valid: false };
        }
        if (Array.isArray(value)) {
          fieldConfig.array = true;
          if (value.length === 0) {
            return { config: fieldConfig, valid: false };
          }
          const arrayTypeResult = detectArrayType(value);
          if (!arrayTypeResult.valid) {
            return { config: fieldConfig, valid: false };
          }
          fieldConfig.type = arrayTypeResult.type;
          if (arrayTypeResult.type === FIELD_TYPES.OBJECT) {
            fieldConfig.objName = fieldName;
          }
        }
        else {
          fieldConfig.type = FIELD_TYPES.OBJECT;
          fieldConfig.objName = fieldName;
        }
        break;
      default:
        return { config: fieldConfig, valid: false };
    }
    if (fieldName.endsWith(REFERENCE_SUFFIX)) {
      fieldConfig.type = FIELD_TYPES.REF;
      fieldConfig.refTo = resolveRefTarget(builder, fieldName, fieldConfig.array || false);
    }
    return { config: fieldConfig, valid: true };
  };
  const detectGroupFields = (builder, fieldName, value) => {
    const result = detectFieldConfig(builder, fieldName, value);
    if (!result.valid) {
      return;
    }
    if (fieldName in builder.fields) {
      return;
    }
    builder.fields[fieldName] = result.config;
  };
  const analyzeObjectStructure = (builder, objFieldName, obj, parentPath) => {
    const objConfig = {
      fields: {},
    };
    for (const [fieldName, value] of Object.entries(obj)) {
      if (value === null || value === undefined) {
        continue;
      }
      const result = detectFieldConfig(builder, fieldName, value);
      if (!result.valid) {
        continue;
      }
      const detected = result.config;
      if (detected.type === FIELD_TYPES.OBJECT) {
        const nestedObjectParentPath = buildObjectName(parentPath, objFieldName);
        detected.objName = buildObjectName(nestedObjectParentPath, fieldName);
      }
      objConfig.fields[fieldName] = detected;
    }
    return objConfig;
  };
  const analyzeObjectStructureFromArray = (builder, fieldName, arr, parentPath) => {
    let accumulated = { fields: {} };
    for (const item of arr) {
      if (typeof item !== 'object' || item === null || Array.isArray(item)) {
        continue;
      }
      const objStruct = analyzeObjectStructure(builder, fieldName, item, parentPath);
      accumulated = mergeObjectConfigs(accumulated, objStruct);
    }
    return accumulated;
  };
  const detectObjectConfig = (builder, fieldName, value, parentPath) => {
    if (typeof value !== 'object' || value === null) {
      return { config: { fields: {} }, valid: false };
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return { config: { fields: {} }, valid: false };
      }
      if (typeof value[0] !== 'object' || value[0] === null || Array.isArray(value[0])) {
        return { config: { fields: {} }, valid: false };
      }
      return {
        config: analyzeObjectStructureFromArray(builder, fieldName, value, parentPath),
        valid: true,
      };
    }
    else {
      return {
        config: analyzeObjectStructure(builder, fieldName, value, parentPath),
        valid: true,
      };
    }
  };
  const detectGroupObjects = (builder, fieldName, value, parentPath) => {
    if (value === null || value === undefined) {
      return;
    }
    const result = detectObjectConfig(builder, fieldName, value, parentPath);
    if (!result.valid || Object.keys(result.config.fields).length === 0) {
      return;
    }
    const fullObjName = buildObjectName(parentPath, fieldName);
    if (fullObjName in builder.objects) {
      const existing = builder.objects[fullObjName];
      builder.objects[fullObjName] = mergeObjectConfigs(existing, result.config);
    }
    else {
      builder.objects[fullObjName] = result.config;
    }
    // Continue traversing deeper levels
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
            for (const [k, vv] of Object.entries(item)) {
              detectGroupObjects(builder, k, vv, fullObjName);
            }
          }
        }
      }
      else {
        for (const [k, vv] of Object.entries(value)) {
          detectGroupObjects(builder, k, vv, fullObjName);
        }
      }
    }
  };
  const buildGroupConfig = (builder, groupEntries) => {
    if (groupEntries.length === 0) {
      return false;
    }
    for (const gEntry of groupEntries) {
      if (Object.keys(gEntry).length === 0) {
        continue;
      }
      for (const [fieldName, value] of Object.entries(gEntry)) {
        if (value === null || value === undefined) {
          continue;
        }
        detectGroupFields(builder, fieldName, value);
        detectGroupObjects(builder, fieldName, value, '');
      }
    }
    return true;
  };
  // Main function
  export const generateSchemaFromData = (source) => {
    const schema = {
      namespace: MANUAL_FILL_PLACEHOLDER,
      typePrefix: MANUAL_FILL_PLACEHOLDER,
      groups: {},
    };
    for (const [groupName, groupEntries] of Object.entries(source)) {
      if (groupEntries.length === 0) {
        continue;
      }
      const builder = createGroupConfBuilder(source, groupName);
      const success = buildGroupConfig(builder, groupEntries);
      if (!success) {
        continue;
      }
      const groupConfig = {
        fields: builder.fields,
      };
      if (Object.keys(builder.objects).length > 0) {
        groupConfig.objects = builder.objects;
      }
      schema.groups[groupName] = groupConfig;
    }
    return schema;
  };
  // JSON serialization function
  const writeFieldConfigInline = (fieldConfig) => {
    const parts = [`"type": "${fieldConfig.type}"`];
    if (fieldConfig.array) {
      parts.push('"array": true');
    }
    if (fieldConfig.filter) {
      parts.push('"filter": true');
    }
    if (fieldConfig.objName) {
      parts.push(`"objName": "${fieldConfig.objName}"`);
    }
    if (fieldConfig.refTo) {
      parts.push(`"refTo": "${fieldConfig.refTo}"`);
    }
    return `{ ${parts.join(', ')} }`;
  };
  export const serializeToJson = (cfg) => {
    const indent = (n) => '  '.repeat(n);
    const lines = [];
    lines.push('{');
    lines.push(`${indent(1)}"namespace": "${cfg.namespace}",`);
    lines.push(`${indent(1)}"typePrefix": "${cfg.typePrefix}",`);
    lines.push(`${indent(1)}"groups": {`);
    const groupNames = Object.keys(cfg.groups).sort();
    groupNames.forEach((groupName, groupIdx) => {
      const group = cfg.groups[groupName];
      if (groupIdx > 0) {
        lines.push(',');
      }
      lines.push(`${indent(2)}"${groupName}": {`);
      lines.push(`${indent(3)}"fields": {`);
      const fieldNames = Object.keys(group.fields).sort();
      if (fieldNames.length > 0) {
        fieldNames.forEach((fieldName, fieldIdx) => {
          const fieldConfig = group.fields[fieldName];
          const comma = fieldIdx < fieldNames.length - 1 ? ',' : '';
          lines.push(`${indent(4)}"${fieldName}": ${writeFieldConfigInline(fieldConfig)}${comma}`);
        });
      }
      lines.push(`${indent(3)}}`);
      if (group.objects && Object.keys(group.objects).length > 0) {
        lines.push(',');
        lines.push(`${indent(3)}"objects": {`);
        const objNames = Object.keys(group.objects).sort();
        objNames.forEach((objName, objIdx) => {
          const obj = group.objects[objName];
          if (objIdx > 0) {
            lines.push(',');
          }
          lines.push(`${indent(4)}"${objName}": {`);
          lines.push(`${indent(5)}"fields": {`);
          const objFieldNames = Object.keys(obj.fields).sort();
          if (objFieldNames.length > 0) {
            objFieldNames.forEach((fieldName, fieldIdx) => {
              const fieldConfig = obj.fields[fieldName];
              const comma = fieldIdx < objFieldNames.length - 1 ? ',' : '';
              lines.push(`${indent(6)}"${fieldName}": ${writeFieldConfigInline(fieldConfig)}${comma}`);
            });
          }
          lines.push(`${indent(5)}}`);
          lines.push(`${indent(4)}}`);
        });
        lines.push(`${indent(3)}}`);
      }
      lines.push(`${indent(2)}}`);
    });
    if (groupNames.length > 0) {
      lines.push('');
    }
    lines.push(`${indent(1)}}`);
    lines.push('}');
    return lines.join('\n');
  };
  // Export all constants for external use
  export const CONSTANTS = {
    MANUAL_FILL_PLACEHOLDER,
    REFERENCE_SUFFIX,
    REF_FIELD_NAME_SUFFIX,
    FIELD_TYPES,
    FIELD_NAMES,
  };
  //# sourceMappingURL=schema-generator.js.map
</script>

<script>
  (function () {
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const resetBtn = document.getElementById('resetBtn');
    const errorBox = document.getElementById('errorBox');
    const successBox = document.getElementById('successBox');
    const resultPreview = document.getElementById('resultPreview');
    const downloadLink = document.getElementById('downloadLink');

    let currentDownloadUrl = null;

    function clearError() { errorBox.style.display = 'none'; errorBox.textContent = ''; }
    function showError(msg) { errorBox.textContent = msg; errorBox.style.display = 'block'; successBox.style.display = 'none'; }
    function showSuccess(msg) { successBox.textContent = msg; successBox.style.display = 'block'; errorBox.style.display = 'none'; }
    function resetUI(full = false) {
      clearError();
      if (currentDownloadUrl) { URL.revokeObjectURL(currentDownloadUrl); currentDownloadUrl = null; }
      downloadLink.style.display = 'none';
      resultPreview.textContent = '—';
      successBox.style.display = 'none';
      if (full) {
        fileInput.value = '';
        processBtn.disabled = true;
      }
    }

    fileInput.addEventListener('change', () => {
      resetUI();
      processBtn.disabled = !fileInput.files || fileInput.files.length === 0;
    });

    resetBtn.addEventListener('click', () => {
      resetUI(true);
    });

    processBtn.addEventListener('click', async () => {
      clearError();
      if (!fileInput.files || fileInput.files.length === 0) {
        showError('Пожалуйста, выберите JSON-файл.');
        return;
      }

      const file = fileInput.files[0];
      try {
        const text = await file.text();
        let data, schema, _output;
        try {
          data = JSON.parse(text);
          schema = generateSchemaFromData(data);
        } catch (e) {
          showError('Файл не является валидным JSON.\n' + (e && e.message ? e.message : ''));
          return;
        }

        if (data === null || Array.isArray(data) || typeof data !== 'object') {
          showError('Ожидается JSON-объект на верхнем уровне (например: { "a": 1, "b": 2 }).');
          return;
        }

        _output = serializeToJson(schema)
        const jsonStr = JSON.stringify(_output, null, 2);

        resultPreview.textContent = jsonStr;
        showSuccess(`Готово: найдено верхнеуровневых полей — ${n}.`);

        const blob = new Blob([jsonStr + "\n"], { type: 'application/json' });
        if (currentDownloadUrl) URL.revokeObjectURL(currentDownloadUrl);
        currentDownloadUrl = URL.createObjectURL(blob);
        downloadLink.href = currentDownloadUrl;
        downloadLink.style.display = 'inline-flex';
      } catch (err) {
        showError('Неожиданная ошибка при обработке файла. ' + (err && err.message ? err.message : ''));
      }
    });
  })();
</script>
</body>
</html>
